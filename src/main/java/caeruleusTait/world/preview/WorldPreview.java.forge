package caeruleusTait.world.preview;

import caeruleusTait.world.preview.backend.WorkManager;
import caeruleusTait.world.preview.backend.color.PreviewMappingData;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.server.MinecraftServer;
import net.minecraftforge.fml.common.Mod;
import net.minecraftforge.fml.loading.FMLPaths;
import net.minecraftforge.fml.util.thread.SidedThreadGroups;
import net.minecraftforge.server.ServerLifecycleHooks;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;
import java.util.Map;
import java.util.concurrent.Executor;
import java.util.concurrent.Executors;
import java.util.stream.Collectors;

@Mod("world_preview")
public class WorldPreview {
    // This logger is used to write text to the console and the log file.
    // It is considered best practice to use your mod id as the logger's name.
    // That way, it's clear which mod wrote info, warnings, and errors.
    public static final Logger LOGGER = LoggerFactory.getLogger("world_preview");

    private static WorldPreview INSTANCE;

    private Path configFile;
    private Path missingColorsFile;
    private Path missingStructuresFile;
    private Path userColorConfigFile;
    private Gson gson;

    private WorldPreviewConfig cfg;
    private WorkManager workManager;
    private PreviewMappingData previewMappingData;
    private RenderSettings renderSettings;

    public static WorldPreview get() {
        return INSTANCE;
    }

    public WorldPreview() {
        INSTANCE = this;

        gson = new GsonBuilder()
                .serializeNulls()
                .setPrettyPrinting()
                .create();

        final Path configDir = FMLPaths.CONFIGDIR.get().resolve("world_preview");
        if (!Files.exists(configDir)) {
            configDir.toFile().mkdirs();
        }
        configFile = configDir.resolve("config.json");
        missingColorsFile = configDir.resolve("missing-colors.json");
        missingStructuresFile = configDir.resolve("missing-structures.json");
        userColorConfigFile = configDir.resolve("biome-colors.json");

        loadConfig();

        renderSettings = new RenderSettings();
        workManager = new WorkManager(renderSettings, cfg);
        previewMappingData = new PreviewMappingData();
    }

    public Executor serverThreadPoolExecutor() {
        return Executors.newSingleThreadExecutor(SidedThreadGroups.SERVER);
    }

    public void loaderSpecificSetup(MinecraftServer minecraftServer) {
        ServerLifecycleHooks.handleServerAboutToStart(minecraftServer);
    }

    public void loaderSpecificTeardown(MinecraftServer minecraftServer) {
        ServerLifecycleHooks.handleServerStopped(minecraftServer);
    }

    public WorldPreviewConfig cfg() {
        return cfg;
    }

    public WorkManager workManager() {
        return workManager;
    }

    public PreviewMappingData biomeColorMap() {
        return previewMappingData;
    }

    public RenderSettings renderSettings() {
        return renderSettings;
    }

    public Path userColorConfigFile() {
        return userColorConfigFile;
    }

    public void loadConfig() {
        LOGGER.info("Loading config file: {}", configFile);
        if (!Files.exists(configFile)) {
            cfg = new WorldPreviewConfig();
            return;
        }
        try {
            cfg = gson.fromJson(Files.readString(configFile), WorldPreviewConfig.class);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    public void saveConfig() {
        LOGGER.info("Saving config file: {}", configFile);
        try {
            Files.writeString(configFile, gson.toJson(cfg) + "\n");
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    public void writeMissingColors(List<String > missing) {
        try {
            Files.deleteIfExists(missingColorsFile);
            if (missing.isEmpty()) {
                return;
            }
            LOGGER.warn("No color mapping for {} biomes found. The list of biomes without a color mapping can be found in {}", missing.size(), missingColorsFile);
            final String raw = gson.toJson(missing);
            Files.writeString(missingColorsFile, raw + "\n");
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    public void writeMissingStructures(List<String> missing) {
        try {
            Files.deleteIfExists(missingStructuresFile);
            if (missing.isEmpty()) {
                return;
            }
            LOGGER.warn("No structure data for {} structure found. The list of structures without data can be found in {}", missing.size(), missingStructuresFile);
            final String raw = gson.toJson(missing);
            Files.writeString(missingStructuresFile, raw + "\n");
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    public void writeUserColorConfig(Map<ResourceLocation, PreviewMappingData.ColorEntry> userColorConfig) {
        record Entry(int r, int g, int b, boolean cave) {}
        Map<String, Entry> writeData = userColorConfig.entrySet()
                .stream()
                .collect(Collectors.toMap(x -> x.getKey().toString(), x -> {
                    PreviewMappingData.ColorEntry raw = x.getValue();
                    final int r = (raw.color >> 16) & 0xFF;
                    final int g = (raw.color >> 8) & 0xFF;
                    final int b = raw.color & 0xFF;
                    return new Entry(r, g, b, raw.cave.orElseThrow());
                }));

        final String raw = gson.toJson(writeData);
        try {
            Files.writeString(userColorConfigFile, raw + "\n");
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    public static int nativeColor(int orig) {
        /*
        final int R = (orig >> 16) & 0xFF;
        final int G = (orig >> 8) & 0xFF;
        final int B = (orig >> 0) & 0xFF;
        return (R << 16) | (G << 8) | (B << 0) | (0xFF << 24);
         */
        return orig | (0xFF << 24);
    }
}